from pathlib import Path
path = Path(r"C:\language\mdsol\src\main.rs")
text = path.read_text()
old = "fn draw_card_face_up_to_dc(\n    state: &WindowState,\n    metrics: &CardMetrics,\n    target_dc: HDC,\n    card: &Card,\n    x: i32,\n    y: i32,\n) {\n    let rect = make_rect(x, y, metrics.card_w, metrics.card_h);\n    unsafe {\n        if let (Some(image), true) = (state.card.as_ref(), state.card_dc.0 != 0) {\n            let radius = (metrics.card_w.min(metrics.card_h) / 6).max(6);\n            draw_round_rect_fill(\n                target_dc,\n                rect,\n                radius,\n                rgb(252, 252, 252),\n                rgb(204, 204, 204),\n            );\n            let sprite = card.sprite_index as i32;\n            let src_x = (sprite % CARD_SPRITE_COLS) * image.cell_w;\n            let src_y = (sprite / CARD_SPRITE_COLS) * image.cell_h;\n            let trim_x = 1;\n            let trim_y = 1;\n            let src_w = (image.cell_w - trim_x * 2).max(1);\n            let src_h = (image.cell_h - trim_y * 2).max(1);\n            let blend = BLENDFUNCTION {\n                BlendOp: AC_SRC_OVER as u8,\n                BlendFlags: 0,\n                SourceConstantAlpha: 255,\n                AlphaFormat: AC_SRC_ALPHA as u8,\n            };\n            let max_inset_w = ((rect.right - rect.left) / 2).saturating_sub(1);\n            let max_inset_h = ((rect.bottom - rect.top) / 2).saturating_sub(1);\n            let face_gap = (metrics.card_w.min(metrics.card_h) / 32).max(2);\n            let inset = metrics\n                .face_inset\n                .saturating_add(face_gap)\n                .min(max_inset_w)\n                .min(max_inset_h)\n                .max(0);\n            let inner = if inset > 0 {\n                inset_rect(rect, inset)\n            } else {\n                rect\n            };\n            let dest_w = (inner.right - inner.left).max(0);\n            let dest_h = (inner.bottom - inner.top).max(0);\n            if dest_w > 0 && dest_h > 0 {\n                AlphaBlend(\n                    target_dc,\n                    inner.left,\n                    inner.top,\n                    dest_w,\n                    dest_h,\n                    state.card_dc,\n                    src_x + trim_x,\n                    src_y + trim_y,\n                    src_w,\n                    src_h,\n                    blend,\n                );\n            }\n        } else {\n            draw_card_placeholder_dc(target_dc, metrics, x, y);\n        }\n    }\n}\n\n"
if old not in text:
    raise SystemExit('original draw_card_face_up_to_dc not found')
new = "fn draw_card_face_up_to_dc(\n    card_image: Option<&CardImage>,\n    card_dc: HDC,\n    metrics: &CardMetrics,\n    target_dc: HDC,\n    card: &Card,\n    x: i32,\n    y: i32,\n) {\n    let rect = make_rect(x, y, metrics.card_w, metrics.card_h);\n    unsafe {\n        if let (Some(image), true) = (card_image, card_dc.0 != 0) {\n            let radius = (metrics.card_w.min(metrics.card_h) / 6).max(6);\n            draw_round_rect_fill(\n                target_dc,\n                rect,\n                radius,\n                rgb(252, 252, 252),\n                rgb(204, 204, 204),\n            );\n            let sprite = card.sprite_index as i32;\n            let src_x = (sprite % CARD_SPRITE_COLS) * image.cell_w;\n            let src_y = (sprite / CARD_SPRITE_COLS) * image.cell_h;\n            let trim_x = 1;\n            let trim_y = 1;\n            let src_w = (image.cell_w - trim_x * 2).max(1);\n            let src_h = (image.cell_h - trim_y * 2).max(1);\n            let blend = BLENDFUNCTION {\n                BlendOp: AC_SRC_OVER as u8,\n                BlendFlags: 0,\n                SourceConstantAlpha: 255,\n                AlphaFormat: AC_SRC_ALPHA as u8,\n            };\n            let max_inset_w = ((rect.right - rect.left) / 2).saturating_sub(1);\n            let max_inset_h = ((rect.bottom - rect.top) / 2).saturating_sub(1);\n            let face_gap = (metrics.card_w.min(metrics.card_h) / 32).max(2);\n            let inset = metrics\n                .face_inset\n                .saturating_add(face_gap)\n                .min(max_inset_w)\n                .min(max_inset_h)\n                .max(0);\n            let inner = if inset > 0 {\n                inset_rect(rect, inset)\n            } else {\n                rect\n            };\n            let dest_w = (inner.right - inner.left).max(0);\n            let dest_h = (inner.bottom - inner.top).max(0);\n            if dest_w > 0 && dest_h > 0 {\n                AlphaBlend(\n                    target_dc,\n                    inner.left,\n                    inner.top,\n                    dest_w,\n                    dest_h,\n                    card_dc,\n                    src_x + trim_x,\n                    src_y + trim_y,\n                    src_w,\n                    src_h,\n                    blend,\n                );\n            }\n        } else {\n            draw_card_placeholder_dc(target_dc, metrics, x, y);\n        }\n    }\n}\n\n"
path.write_text(text.replace(old, new, 1))
