# Windows 11 Desktop Overlay - High Level Design
**Date:** 2025.09.13
**Version:** 1.0
**Status:** Reviewed and Approved with Feedback

## 1. Overview - What We're Building

A single, pinned, transparent overlay that sits top-center on the primary monitor, showing one line:

```
DESKTOP TITLE: what I'm doing on this desktop
```

### Key Features
- Auto-updates when the user switches virtual desktops
- Edit Title and Description via global hotkeys (quick input dialogs)
- Global hotkey toggles overlay visibility
- System tray icon with menu options:
  - Edit Titleâ€¦
  - Edit Descriptionâ€¦
  - Toggle Overlay
  - Settings (open config file)
  - Exit
- Text persists per virtual desktop across restarts

### Window Characteristics
- Always-on-top (`HWND_TOPMOST`) and hidden from Alt-Tab (tool window)
- Transparent with per-pixel alpha (render text onto ARGB bitmap and blit with `UpdateLayeredWindow`)
- Non-rectangular, crisp appearance

## 2. Key Technology Decisions

### Windows API Bindings
- **Choice:** `windows` (windows-rs) crate
- **Rationale:** First-class, modern Win32/COM access. Microsoft-backed and supersedes winapi for new code
- **Reference:** [Microsoft Learn - Rust for Windows](https://learn.microsoft.com/en-us/windows/dev-environment/rust/)

### Virtual Desktop Detection & Metadata
- **Choice:** `winvd` crate (Windows 11 virtual desktop bindings)
- **Features:**
  - `get_current_desktop()` - yields current desktop/GUID
  - `listen_desktop_events(sender)` - desktop switched notifications
  - Pin/unpin window, get/set desktop names
- **Compatibility:** Built from VirtualDesktopAccessor, supports Windows 11 24H2 (26100.2605)+
- **Fallback:** Earlier builds use low-frequency poll loop
- **Reference:** [winvd on docs.rs](https://docs.rs/winvd)

### Rendering
- **Approach:** Transparent, per-pixel alpha overlay using `WS_EX_LAYERED` + `UpdateLayeredWindow`
- **Text Rendering:** DirectWrite/Direct2D for subpixel-antialiased text
- **Process:** Draw text â†’ ARGB bitmap â†’ push via UpdateLayeredWindow
- **Reference:** [UpdateLayeredWindow](https://learn.microsoft.com/en-us/windows/win32/api/winuser/nf-winuser-updatelayeredwindow)

### System Tray
- **Approach:** Minimal footprint using `Shell_NotifyIconW` directly
- **Alternative:** `tray-icon` crate for cross-platform abstraction
- **Reference:** [Shell_NotifyIcon](https://learn.microsoft.com/en-us/windows/win32/api/shellapi/nf-shellapi-shell_notifyiconw)

### Hotkeys
- **Implementation:** Win32 `RegisterHotKey` (`WM_HOTKEY`)
- **Note:** Avoid `MOD_WIN` as Windows reserves many Win+ combinations
- **Reference:** [RegisterHotKey](https://learn.microsoft.com/en-us/windows/win32/api/winuser/nf-winuser-registerhotkey)

### Monitor & DPI
- **Primary Monitor:** Compute top-center rectangle using `MONITORINFO.dwFlags & MONITORINFOF_PRIMARY`
- **DPI:** Per-Monitor v2 DPI awareness via application manifest (preferred)
- **Reference:** [DPI Awareness](https://learn.microsoft.com/en-us/windows/win32/hidpi/dpi-awareness-context)

### Persistence
- **Location:** `%APPDATA%\Vendor\App\config\labels.json`
- **Directory Management:** `directories::ProjectDirs`
- **Serialization:** `serde` + `serde_json`
- **Reference:** [directories crate](https://docs.rs/directories)

## 3. Window Styles & Behavior

### Window Styles
- **Base:** `WS_POPUP` (no border, no caption)

### Extended Styles
- `WS_EX_TOPMOST` - Always on top
- `WS_EX_TOOLWINDOW` - Hide from Alt-Tab
- `WS_EX_LAYERED` - Per-pixel alpha
- Optional: `WS_EX_TRANSPARENT` - Pass clicks through (default off for interaction)

### Virtual Desktop Behavior
- Pin overlay window via `winvd::pin_window(hwnd)` to show across all desktops
- Text content changes dynamically based on current desktop

## 4. Hotkeys (Default Configuration)

| Action | Default Hotkey | Mnemonic |
|--------|---------------|----------|
| Edit Title | Ctrl+Alt+T | T = Title |
| Edit Description | Ctrl+Alt+D | D = Description |
| Toggle Overlay | Ctrl+Alt+O | O = Overlay |

**Note:** These avoid Win+ combinations which are often OS-reserved and may be blocked.

## 5. Configuration & Persistence

### File Location
`%APPDATA%\Acme\DesktopLabeler\config\labels.json`

### Configuration Schema
```json
{
  "desktops": {
    "{GUID}": {
      "title": "Work",
      "description": "Focus on tickets"
    },
    "{GUID}": {
      "title": "Meetings",
      "description": "Teams/Zoom"
    }
  },
  "hotkeys": {
    "edit_title": { "ctrl": true, "alt": true, "key": "T" },
    "edit_description": { "ctrl": true, "alt": true, "key": "D" },
    "toggle_overlay": { "ctrl": true, "alt": true, "key": "O" }
  },
  "appearance": {
    "font_family": "Segoe UI",
    "font_size_dip": 16,
    "margin_px": 8
  }
}
```

## 6. Desktop Switch Detection Strategy

### Primary Method (Windows 11 24H2+)
1. Start `winvd::listen_desktop_events(sender)`
2. Receive `DesktopEvent::Switched(GUID)` events
3. Update text immediately
4. Keep `DesktopEventThread` handle alive (joined when dropped)
5. Fetch `get_current_desktop()` at startup for initial GUID

### Fallback Method (Older Builds)
- Poll `get_current_desktop()` at ~4 Hz using waitable timer
- Very light CPU usage, <250ms responsiveness
- Automatically activate if `listen_desktop_events` fails

**Note:** Microsoft's public `IVirtualDesktopManager` doesn't provide current desktop or notifications. The community-maintained VirtualDesktopAccessor (used by winvd) requires Windows 11 24H2.

## 7. Primary Monitor Placement & DPI

### Monitor Detection
1. Call `MonitorFromPoint(0,0)`
2. Get `GetMonitorInfo` â†’ check `MONITORINFOF_PRIMARY`
3. Use `rcWork` (work area excludes taskbar)

### DPI Handling
1. Enable Per-Monitor v2 DPI in manifest (preferred) or via `SetProcessDpiAwarenessContext`
2. Handle `WM_DPICHANGED` to reposition/resize cleanly
3. Measure text with DirectWrite `IDWriteTextLayout` for exact pixel dimensions
4. Center calculation: `x = work_left + (work_width - overlay_width)/2, y = work_top + margin`

## 8. System Tray Integration

### Implementation
1. Add icon via `Shell_NotifyIconW` with `NOTIFYICONDATAW`
2. Set callback message (`WM_APP + 1`)
3. On right-click, show `CreatePopupMenu` with menu items
4. Optional: Use `tray-icon` crate for managed menu/event loop

## 9. Error Handling & Edge Cases

### Monitor Changes
- Handle `WM_DISPLAYCHANGE` and `WM_DPICHANGED`
- Recompute layout and call `UpdateLayeredWindow` again

### Power Management
- Handle `WM_POWERBROADCAST` (`PBT_APMRESUMEAUTOMATIC`)
- Recreate D2D/DirectWrite resources if needed and redraw

### Configuration I/O
- Keep in-memory copy
- On write failure: toast via tray balloon, retry later

### Virtual Desktop Events
- Automatically fall back to polling if `listen_desktop_events` unavailable

### Hotkey Conflicts
- Check `RegisterHotKey` return value
- If fails: show tray notification with alternative suggestion
- Avoid `MOD_WIN` defaults (many reserved)

## 10. Dependencies

```toml
[package]
name = "desktop-overlay"
version = "0.1.0"
edition = "2021"

[dependencies]
windows = { version = "0.58", features = [
  "Win32_Foundation",
  "Win32_System_Com",
  "Win32_UI_WindowsAndMessaging",
  "Win32_UI_Shell",
  "Win32_Graphics_Gdi",
  "Win32_Graphics_Direct2D",
  "Win32_Graphics_DirectWrite",
  "Win32_Graphics_Dxgi",
  "Win32_System_Power",
  "Win32_UI_Input_KeyboardAndMouse"
]}
winvd = "0.0.48"               # virtual desktop events & helpers (Win11 24H2+)
serde = { version = "1", features = ["derive"] }
serde_json = "1"
directories = "5"
anyhow = "1"
thiserror = "1"
once_cell = "1"

[build-dependencies]
embed-manifest = "1"           # embed app manifest for PerMonitorV2 DPI, etc.
```

## 11. Build Configuration

### build.rs
```rust
fn main() {
    // Embed a manifest enabling Per-Monitor v2 DPI awareness.
    embed_manifest::embed_manifest_file("app.manifest").unwrap();
    // Optional: include a .rc to embed an icon too (via embed-resource).
}
```

### app.manifest
```xml
<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<assembly manifestVersion="1.0" xmlns="urn:schemas-microsoft-com:asm.v1">
  <assemblyIdentity version="1.0.0.0" processorArchitecture="*"
                    name="Acme.DesktopLabeler" type="win32"/>
  <application xmlns="urn:schemas-microsoft-com:asm.v3">
    <windowsSettings>
      <dpiAwareness xmlns="http://schemas.microsoft.com/SMI/2016/WindowsSettings">
        PerMonitorV2
      </dpiAwareness>
    </windowsSettings>
  </application>
</assembly>
```

## 12. Source Code Layout

```
src/
  main.rs            // WinMain, message loop
  overlay.rs         // layered window + D2D/DWrite rendering
  vd.rs              // virtual desktop wiring (winvd + fallback polling)
  hotkeys.rs         // RegisterHotKey/UnregisterHotKey
  tray.rs            // Shell_NotifyIcon, popup menu
  config.rs          // serde types, load/save
```

## 13. Implementation Code Skeletons

### src/config.rs
```rust
use serde::{Deserialize, Serialize};
use std::{collections::HashMap, fs, path::PathBuf};
use directories::ProjectDirs;
use anyhow::{Context, Result};

#[derive(Debug, Clone, Serialize, Deserialize, Default)]
pub struct DesktopLabel {
    pub title: String,
    pub description: String
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct Hotkey {
    pub ctrl: bool,
    pub alt: bool,
    pub shift: bool,
    pub key: char
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct Config {
    pub desktops: HashMap<String, DesktopLabel>,
    pub hotkeys: Hotkeys,
    pub appearance: Appearance
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct Hotkeys {
    pub edit_title: Hotkey,
    pub edit_description: Hotkey,
    pub toggle_overlay: Hotkey
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct Appearance {
    pub font_family: String,
    pub font_size_dip: f32,
    pub margin_px: i32
}

impl Default for Config {
    fn default() -> Self {
        Self {
            desktops: HashMap::new(),
            hotkeys: Hotkeys {
                edit_title: Hotkey { ctrl: true, alt: true, shift: false, key: 'T' },
                edit_description: Hotkey { ctrl: true, alt: true, shift: false, key: 'D' },
                toggle_overlay: Hotkey { ctrl: true, alt: true, shift: false, key: 'O' },
            },
            appearance: Appearance {
                font_family: "Segoe UI".into(),
                font_size_dip: 16.0,
                margin_px: 8
            }
        }
    }
}

pub struct Paths {
    pub cfg_dir: PathBuf,
    pub cfg_file: PathBuf
}

pub fn paths() -> Result<Paths> {
    let pd = ProjectDirs::from("com", "Acme", "DesktopLabeler")
        .context("cannot resolve ProjectDirs")?;
    let cfg_dir = pd.config_dir().to_path_buf();
    Ok(Paths {
        cfg_file: cfg_dir.join("labels.json"),
        cfg_dir
    })
}

pub fn load_or_default() -> Result<(Config, Paths)> {
    let p = paths()?;
    fs::create_dir_all(&p.cfg_dir)?;
    let cfg = if p.cfg_file.exists() {
        let txt = fs::read_to_string(&p.cfg_file)?;
        serde_json::from_str(&txt)?
    } else {
        Config::default()
    };
    Ok((cfg, p))
}

pub fn save(cfg: &Config, p: &Paths) -> Result<()> {
    fs::create_dir_all(&p.cfg_dir)?;
    let s = serde_json::to_string_pretty(cfg)?;
    fs::write(&p.cfg_file, s)?;
    Ok(())
}
```

### src/vd.rs
```rust
use std::{sync::{mpsc, Arc, atomic::{AtomicBool, Ordering}}, thread, time::Duration};
use anyhow::Result;
use winvd::{listen_desktop_events, get_current_desktop, DesktopEvent, pin_window};
use windows::Win32::Foundation::HWND;

pub enum VdMsg {
    Switched(String /*GUID as string*/)
}

pub struct VdWatcher {
    pub rx: mpsc::Receiver<VdMsg>,
    stop: Arc<AtomicBool>,
    _thread: Option<winvd::DesktopEventThread>, // keep alive if using events
}

pub fn pin_overlay(hwnd: HWND) {
    let _ = pin_window(hwnd); // ignore errors silently
}

pub fn start() -> Result<VdWatcher> {
    let (tx, rx) = mpsc::channel();
    let stop = Arc::new(AtomicBool::new(false));

    // Try event-based listener (24H2+)
    if let Ok(thread_handle) = listen_desktop_events(tx.clone()) {
        // Event path
        return Ok(VdWatcher { rx, stop, _thread: Some(thread_handle) });
    }

    // Fallback: poll current desktop every 250ms
    let stop2 = stop.clone();
    thread::spawn(move || {
        let mut last = String::new();
        while !stop2.load(Ordering::SeqCst) {
            if let Ok(d) = get_current_desktop() {
                let id = format!("{:?}", d.id); // or d.get_name().unwrap_or_default()
                if id != last {
                    last = id.clone();
                    let _ = tx.send(VdMsg::Switched(id));
                }
            }
            thread::sleep(Duration::from_millis(250));
        }
    });

    Ok(VdWatcher { rx, stop, _thread: None })
}

impl Drop for VdWatcher {
    fn drop(&mut self) {
        self.stop.store(true, Ordering::SeqCst);
    }
}
```

### src/hotkeys.rs
```rust
use windows::Win32::UI::Input::KeyboardAndMouse::{
    RegisterHotKey, UnregisterHotKey, MOD_ALT, MOD_CONTROL,
    MOD_SHIFT, MOD_NOREPEAT, VIRTUAL_KEY
};
use windows::Win32::Foundation::{BOOL, HWND};
use anyhow::{Result, anyhow};

pub const HK_EDIT_TITLE: i32 = 1001;
pub const HK_EDIT_DESC:  i32 = 1002;
pub const HK_TOGGLE:     i32 = 1003;

fn key_from_char(c: char) -> u32 {
    (c.to_ascii_uppercase() as u8) as u32
}

pub fn register(hwnd: HWND, ctrl: bool, alt: bool, shift: bool,
                key: char, id: i32) -> Result<()> {
    let mut mods = MOD_NOREPEAT.0;
    if ctrl { mods |= MOD_CONTROL.0; }
    if alt  { mods |= MOD_ALT.0; }
    if shift{ mods |= MOD_SHIFT.0; }
    let ok: BOOL = unsafe {
        RegisterHotKey(hwnd, id, mods, VIRTUAL_KEY(key_from_char(key)))
    };
    if ok.as_bool() {
        Ok(())
    } else {
        Err(anyhow!("RegisterHotKey failed for id {}", id))
    }
}

pub fn unregister(hwnd: HWND, id: i32) {
    unsafe { let _ = UnregisterHotKey(hwnd, id); }
}
```

### src/tray.rs
```rust
use windows::Win32::UI::Shell::{
    Shell_NotifyIconW, NOTIFYICONDATAW, NIM_ADD, NIM_MODIFY,
    NIM_DELETE, NIF_ICON, NIF_TIP, NIF_MESSAGE
};
use windows::Win32::Foundation::{HWND, HICON, LPARAM, WPARAM};
use windows::core::PCWSTR;

pub const WM_TRAYICON: u32 = 0x8000; // WM_APP
pub const TRAY_UID: u32 = 1;

pub struct Tray { hwnd: HWND }

impl Tray {
    pub fn new(hwnd: HWND, hicon: HICON, tip: &str) -> Self {
        let mut nid = NOTIFYICONDATAW::default();
        nid.cbSize = std::mem::size_of::<NOTIFYICONDATAW>() as u32;
        nid.hWnd = hwnd;
        nid.uID = TRAY_UID;
        nid.uFlags = NIF_MESSAGE | NIF_ICON | NIF_TIP;
        nid.uCallbackMessage = WM_TRAYICON;
        nid.hIcon = hicon;
        // set tip
        let mut buf: [u16; 128] = [0; 128];
        let w: Vec<u16> = tip.encode_utf16().chain(std::iter::once(0)).collect();
        let n = w.len().min(buf.len());
        buf[..n].copy_from_slice(&w[..n]);
        nid.szTip = buf;
        unsafe { Shell_NotifyIconW(NIM_ADD, &mut nid).ok().unwrap(); }
        Self { hwnd }
    }

    pub fn update_tip(&self, tip: &str) {
        let mut nid = NOTIFYICONDATAW::default();
        nid.cbSize = std::mem::size_of::<NOTIFYICONDATAW>() as u32;
        nid.hWnd = self.hwnd;
        nid.uID = TRAY_UID;
        nid.uFlags = NIF_TIP;
        let mut buf: [u16; 128] = [0; 128];
        let w: Vec<u16> = tip.encode_utf16().chain(std::iter::once(0)).collect();
        let n = w.len().min(buf.len());
        buf[..n].copy_from_slice(&w[..n]);
        nid.szTip = buf;
        unsafe { Shell_NotifyIconW(NIM_MODIFY, &mut nid).ok().unwrap(); }
    }
}

impl Drop for Tray {
    fn drop(&mut self) {
        let mut nid = NOTIFYICONDATAW::default();
        nid.cbSize = std::mem::size_of::<NOTIFYICONDATAW>() as u32;
        nid.hWnd = self.hwnd;
        nid.uID = TRAY_UID;
        unsafe { let _ = Shell_NotifyIconW(NIM_DELETE, &mut nid); }
    }
}
```

### src/overlay.rs
```rust
use anyhow::Result;
use windows::Win32::{
    Foundation::{HWND, POINT, RECT},
    Graphics::{
        Gdi::{
            HBITMAP, BITMAPINFO, BITMAPINFOHEADER, BI_RGB,
            CreateCompatibleDC, CreateDIBSection, SelectObject,
            DeleteObject, DeleteDC, HDC, AlphaBlend, BLENDFUNCTION,
            AC_SRC_ALPHA, AC_SRC_OVER
        },
        Direct2D::{
            D2D1CreateFactory, ID2D1Factory, D2D1_FACTORY_TYPE,
            ID2D1RenderTarget, ID2D1HwndRenderTarget,
            D2D1_RENDER_TARGET_PROPERTIES, D2D1_HWND_RENDER_TARGET_PROPERTIES,
            D2D1_SIZE_U, D2D1CreateFactory
        },
        DirectWrite::{
            DWriteCreateFactory, IDWriteFactory, DWRITE_FACTORY_TYPE,
            IDWriteTextFormat
        },
    },
    UI::WindowsAndMessaging::{
        UpdateLayeredWindow, GetDC, ReleaseDC, SetWindowPos,
        HWND_TOPMOST, SWP_NOACTIVATE, SWP_NOSIZE, SWP_NOMOVE, WS_EX_LAYERED
    },
};
use windows::core::PCWSTR;

pub struct Overlay {
    pub hwnd: HWND,
    dwrite: IDWriteFactory,
    text_fmt: IDWriteTextFormat,
    margin: i32,
}

impl Overlay {
    pub fn new(hwnd: HWND, font_family: &str, font_size_dip: f32,
               margin: i32) -> Result<Self> {
        let dwrite: IDWriteFactory = unsafe {
            let mut f = None;
            DWriteCreateFactory(
                DWRITE_FACTORY_TYPE(0),
                &IDWriteFactory::IID,
                f.set_abi()
            ).ok()?;
            f.unwrap()
        };
        let ws: Vec<u16> = font_family.encode_utf16()
            .chain(std::iter::once(0)).collect();
        let text_fmt = unsafe {
            dwrite.CreateTextFormat(
                PCWSTR(ws.as_ptr()),
                None, // system font collection
                windows::Win32::Graphics::DirectWrite::DWRITE_FONT_WEIGHT_NORMAL,
                windows::Win32::Graphics::DirectWrite::DWRITE_FONT_STYLE_NORMAL,
                windows::Win32::Graphics::DirectWrite::DWRITE_FONT_STRETCH_NORMAL,
                font_size_dip,
                PCWSTR(windows::w!("en-US")),
            )?
        };

        Ok(Self { hwnd, dwrite, text_fmt, margin })
    }

    pub fn draw_line(&self, text: &str, x: i32, y: i32) -> Result<(i32,i32)> {
        // TODO: Implement proper Direct2D rendering
        // 1) Measure text using IDWriteTextLayout
        // 2) Create 32-bit top-down DIB section
        // 3) Draw text onto DIB (Direct2D or GDI+)
        // 4) Call UpdateLayeredWindow with HBITMAP

        let screen_dc = unsafe { GetDC(self.hwnd) };
        let size = windows::Win32::Foundation::SIZE { cx: 800, cy: 32 };
        let src_pt = POINT { x: 0, y: 0 };
        let top_left = POINT { x, y };
        let blend = BLENDFUNCTION {
            BlendOp: AC_SRC_OVER,
            BlendFlags: 0,
            SourceConstantAlpha: 255,
            AlphaFormat: AC_SRC_ALPHA
        };

        // TODO: Create actual memory DC with rendered text
        let hdc_mem: HDC = HDC(0); // placeholder

        unsafe {
            UpdateLayeredWindow(
                self.hwnd, screen_dc, Some(&top_left), Some(&size),
                hdc_mem, Some(&src_pt), 0, Some(&blend), 2
            ).ok()?;
            ReleaseDC(self.hwnd, screen_dc);
        }
        Ok((size.cx, size.cy))
    }

    pub fn set_topmost_noactivate(&self) {
        unsafe {
            SetWindowPos(
                self.hwnd, HWND_TOPMOST, 0, 0, 0, 0,
                SWP_NOACTIVATE | SWP_NOMOVE | SWP_NOSIZE
            ).ok().unwrap();
        }
    }
}
```

### src/main.rs
```rust
#![windows_subsystem = "windows"]

mod config;
mod vd;
mod hotkeys;
mod tray;
mod overlay;

use anyhow::Result;
use config::{load_or_default, save, DesktopLabel};
use vd::{start as start_vd, VdMsg, pin_overlay};
use hotkeys::*;
use tray::{Tray, WM_TRAYICON};
use overlay::Overlay;

use std::{cell::RefCell, collections::HashMap, mem::size_of};
use windows::core::PCWSTR;
use windows::Win32::{
    Foundation::{HWND, LPARAM, LRESULT, WPARAM, RECT},
    System::Power::{PBT_APMRESUMEAUTOMATIC},
    UI::WindowsAndMessaging::*,
    Graphics::Gdi::{GetMonitorInfoW, MonitorFromPoint, MONITORINFO, MONITOR_DEFAULTTOPRIMARY},
};

thread_local! {
    static APP: RefCell<Option<AppState>> = RefCell::new(None);
}

struct AppState {
    hwnd: HWND,
    overlay: Overlay,
    tray: Tray,
    cfg: config::Config,
    cfg_paths: config::Paths,
    current_guid: String,
    visible: bool,
}

fn primary_work_area() -> RECT {
    unsafe {
        let mon = MonitorFromPoint(
            POINT { x: 0, y: 0 },
            MONITOR_DEFAULTTOPRIMARY
        );
        let mut mi = MONITORINFO {
            cbSize: size_of::<MONITORINFO>() as u32,
            ..Default::default()
        };
        GetMonitorInfoW(mon, &mut mi).ok().unwrap();
        mi.rcWork
    }
}

fn update_overlay_text(app: &mut AppState) {
    let label = app.cfg.desktops.get(&app.current_guid).cloned()
        .unwrap_or(DesktopLabel {
            title: format!("Desktop"),
            description: String::new()
        });
    let line = if label.description.is_empty() {
        format!("{}:", label.title)
    } else {
        format!("{}: {}", label.title, label.description)
    };

    let rc = primary_work_area();
    let margin = app.cfg.appearance.margin_px;
    // Measure -> width/height; place at top-center
    let x = rc.left + ((rc.right - rc.left) / 2) - 400/2;
    let y = rc.top + margin;
    let _ = app.overlay.draw_line(&line, x, y);
}

extern "system" fn wndproc(hwnd: HWND, msg: u32, w: WPARAM, l: LPARAM) -> LRESULT {
    match msg {
        WM_CREATE => {
            APP.with(|slot| {
                let (cfg, paths) = load_or_default().expect("config");
                let overlay = Overlay::new(
                    hwnd,
                    &cfg.appearance.font_family,
                    cfg.appearance.font_size_dip,
                    cfg.appearance.margin_px
                ).unwrap();
                overlay.set_topmost_noactivate();
                pin_overlay(hwnd);
                let tray = Tray::new(hwnd, HICON(0), "Desktop Overlay");

                // Register hotkeys
                let hk = &cfg.hotkeys;
                let _ = register(hwnd, hk.edit_title.ctrl, hk.edit_title.alt,
                                hk.edit_title.shift, hk.edit_title.key, HK_EDIT_TITLE);
                let _ = register(hwnd, hk.edit_description.ctrl, hk.edit_description.alt,
                                hk.edit_description.shift, hk.edit_description.key, HK_EDIT_DESC);
                let _ = register(hwnd, hk.toggle_overlay.ctrl, hk.toggle_overlay.alt,
                                hk.toggle_overlay.shift, hk.toggle_overlay.key, HK_TOGGLE);

                // Start VD watcher
                let watcher = start_vd().unwrap();
                let mut current_guid = String::new();
                if let Ok(d) = winvd::get_current_desktop() {
                    current_guid = format!("{:?}", d.id);
                }

                let mut app = AppState {
                    hwnd, overlay, tray, cfg,
                    cfg_paths: paths,
                    current_guid,
                    visible: true
                };
                update_overlay_text(&mut app);
                *slot.borrow_mut() = Some(app);

                // Timer for polling VD changes
                SetTimer(hwnd, 1, 200, None);
            });
            LRESULT(0)
        }
        WM_TIMER => {
            // Check for desktop switch messages
            APP.with(|slot| {
                if let Some(app) = &mut *slot.borrow_mut() {
                    if let Ok(d) = winvd::get_current_desktop() {
                        let id = format!("{:?}", d.id);
                        if id != app.current_guid {
                            app.current_guid = id;
                            update_overlay_text(app);
                        }
                    }
                }
            });
            LRESULT(0)
        }
        WM_HOTKEY => {
            let id = w.0 as i32;
            APP.with(|slot| {
                if let Some(app) = &mut *slot.borrow_mut() {
                    match id {
                        HK_EDIT_TITLE => { quick_edit(app, true); }
                        HK_EDIT_DESC  => { quick_edit(app, false); }
                        HK_TOGGLE     => { toggle_overlay(app); }
                        _ => {}
                    }
                }
            });
            LRESULT(0)
        }
        WM_DISPLAYCHANGE | WM_DPICHANGED => {
            APP.with(|slot| {
                if let Some(app) = &mut *slot.borrow_mut() {
                    update_overlay_text(app);
                }
            });
            LRESULT(0)
        }
        WM_POWERBROADCAST => {
            if w.0 as u32 == PBT_APMRESUMEAUTOMATIC {
                APP.with(|slot| {
                    if let Some(app) = &mut *slot.borrow_mut() {
                        update_overlay_text(app);
                    }
                });
            }
            LRESULT(1)
        }
        WM_DESTROY => {
            PostQuitMessage(0);
            LRESULT(0)
        }
        _ => unsafe { DefWindowProcW(hwnd, msg, w, l) }
    }
}

fn quick_edit(app: &mut AppState, edit_title: bool) {
    // TODO: Show input dialog
    // Update app.cfg.desktops[app.current_guid]
    // Save config and update overlay
}

fn toggle_overlay(app: &mut AppState) {
    app.visible = !app.visible;
    unsafe {
        ShowWindow(app.hwnd, if app.visible { SW_SHOW } else { SW_HIDE });
    }
}

fn main() -> Result<()> {
    unsafe {
        CoInitializeEx(None, COINIT_APARTMENTTHREADED).ok()?;

        let class_name = windows::w!("DesktopLabelerWndClass");
        let hinst = GetModuleHandleW(None).unwrap();
        let wc = WNDCLASSW {
            lpfnWndProc: Some(wndproc),
            hInstance: hinst,
            lpszClassName: class_name,
            ..Default::default()
        };
        RegisterClassW(&wc);

        let hwnd = CreateWindowExW(
            WINDOW_EX_STYLE(WS_EX_TOOLWINDOW.0 | WS_EX_LAYERED.0),
            class_name,
            windows::w!(""),
            WS_POPUP,
            0, 0, 0, 0,
            None, None, hinst, None
        );
        ShowWindow(hwnd, SW_SHOW);

        let mut msg = MSG::default();
        while GetMessageW(&mut msg, HWND(0), 0, 0).into() {
            TranslateMessage(&msg);
            DispatchMessageW(&msg);
        }
        CoUninitialize();
    }
    Ok(())
}
```

## 14. Performance Expectations

- **Idle CPU:** ~0% (no busy waits, only 200ms timer for fallback)
- **Memory:** <10-15 MB in Release mode
- **Redraw:** Only on desktop switch, DPI/monitor change, or edit
- **Event-driven:** Remove timer entirely if using winvd event thread

## 15. Test Checklist

- [ ] Start on Desktop 1; title/description appear top-center on primary monitor
- [ ] Ctrl+Alt+T edits Title (dialog), Ctrl+Alt+D edits Description
- [ ] Switch to Desktop 2 â†’ overlay text updates
- [ ] Toggle visibility with Ctrl+Alt+O
- [ ] Plug another monitor; change scale â†’ overlay realigns
- [ ] Sleep/resume â†’ overlay repaints
- [ ] Exit via tray menu

## 16. Architecture Rationale

| Component | Choice | Reason |
|-----------|--------|--------|
| `windows` | Official Win32/COM bindings | Future-proof, Microsoft-backed |
| `winvd` | Virtual desktop events | Simple high-level API with pinning |
| DirectWrite + UpdateLayeredWindow | Text rendering | Crisp text with true transparency |
| Shell_NotifyIcon | System tray | Minimal footprint, no GUI toolkit |
| Manifest Per-Monitor v2 | DPI awareness | Correctness on multi-DPI setups |

## 17. Known Limitations & Mitigations

| Issue | Impact | Mitigation |
|-------|--------|------------|
| Windows 11 24H2 requirement | Event API unavailable on older builds | Auto-fallback to polling |
| MOD_WIN hotkeys reserved | Many Win+ combos blocked | Default to Ctrl+Alt combinations |
| Anti-aliased text edges | Potential fringing on transparency | Per-pixel alpha via UpdateLayeredWindow |

---

# Review Feedback & Critical Improvements

## Critical Issues to Address

### 1. Thread Safety Bug
**Issue:** `thread_local!` with `RefCell` while VD watcher spawns threads
**Fix:** Use custom window message to bridge thread boundary:
```rust
const WM_VD_SWITCHED: u32 = WM_APP + 2;
// In VD thread: PostMessageW(hwnd, WM_VD_SWITCHED, guid_ptr, 0)
```

### 2. Memory Leaks
**Issue:** Missing cleanup for DIB sections and GDI handles
**Fix:** Implement proper RAII wrappers for all GDI resources

### 3. Race Condition
**Issue:** `static mut VISIBLE` is unsound
**Fix:** Store visibility state in `AppState` or use `AtomicBool`

## Recommended Improvements

### Direct2D Rendering
Replace DIB approach with `ID2D1DCRenderTarget`:
- Create WIC bitmap â†’ D2D render target
- Render text â†’ Get HBITMAP â†’ UpdateLayeredWindow

### Configuration Hot-Reload
Add file watcher on config JSON for live updates

### Input Dialog Alternative
Use `TaskDialogIndirect` for modern, DPI-aware quick edits

## Additional Edge Cases to Handle

1. **Multi-monitor different DPIs:** Cache rendered text per-DPI
2. **Fast user switching/RDP:** Handle `WM_WTSSESSION_CHANGE`
3. **Fullscreen applications:** Auto-hide when exclusive fullscreen detected
4. **High contrast mode:** Check `SystemParametersInfo(SPI_GETHIGHCONTRAST)`
5. **RTL languages:** Use `DWRITE_TEXT_ALIGNMENT_TRAILING`

## Security Considerations

1. **Input validation:** Add length limits to config fields
2. **Hotkey validation:** Prevent system-critical combinations
3. **File permissions:** Ensure config is user-writable only

## Performance Optimizations

1. **Text caching:** Pre-render common strings
2. **Dirty rect tracking:** Only update when text changes
3. **COM apartment:** Consider MTA vs STA based on usage

---

**Final Assessment:** Production-ready architecture with excellent Windows internals knowledge. Fix thread-safety issues before deployment. The dual-strategy for virtual desktop detection and per-pixel alpha rendering shows sophisticated design thinking.

---

# Design Updates (2025-09-13)

The following changes are incorporated to strengthen robustness and operability during implementation.

## Rendering & Readability
- Layered windows do not support ClearType subpixel AA; expect grayscale AA with DirectWrite. Provide an optional 1â€“2 px outline or soft shadow and an optional semiâ€‘transparent backdrop to ensure contrast over busy wallpapers.

## Tray Resilience
- Register and handle `TaskbarCreated` to re-add the tray icon after Explorer restarts. Unregister on shutdown; re-register after resume.

## Single Instance
- Create a named mutex (e.g., `Local\\Acme.DesktopLabeler`) at startup. If already present, signal/focus the existing instance and exit cleanly.

## Hotkeys
- Store values as VK codes plus modifiers in config. Validate conflicts at startup; surface failures via tray balloon and disable the offending binding. Always unregister on exit.

## Configuration I/O
- Atomic saves: write to temp in the same directory, flush, then `rename` to the target file. Add a file watcher (`notify` crate) for live reload. Enforce reasonable length caps on title/description to prevent oversized allocations.

## DPI & Sizing
- On `WM_DPICHANGED`, use the suggested rect from `lParam` with `SetWindowPos` before redrawing. Recompute text layout against the new DPI and recentre using the primary monitorâ€™s work area.

## Sessions, Accessibility, Fullscreen
- Register `WTSRegisterSessionNotification` and handle `WM_WTSSESSION_CHANGE`. Auto-hide when exclusive fullscreen is detected or High Contrast is enabled via `SystemParametersInfo(SPI_GETHIGHCONTRAST)`.

## Logging
- Integrate `tracing`/`tracing-subscriber` with file output in `%APPDATA%/Acme/DesktopLabeler/logs` (INFO by default; DEBUG via env var).

## Naming & Packaging
- Align crate/binary naming (repo currently `mddsklbl`) before CI/installer. Add CI for `fmt`, `clippy -D warnings`, `test`, and Windows release artifacts. Package with Inno Setup or WiX; optional Runâ€‘atâ€‘Login toggle.

## Dependency Delta
- Add: `tracing`, `tracing-subscriber`, `notify` (config hotâ€‘reload). Keep other choices as specified.


