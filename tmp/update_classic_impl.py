from pathlib import Path

path = Path(r"C:\language\mdsol\src\main.rs")
text = path.read_text()
start = text.index("impl ClassicVictoryAnimation {")
end = text.index("enum VictoryAnimation")
old_impl = text[start:end]
new_impl = """impl ClassicVictoryAnimation {\n    fn new(\n        emitters: Vec<ClassicEmitter>,\n        card_height: f32,\n        card_width: f32,\n        viewport_width: f32,\n        layer_size: (i32, i32),\n        now: Instant,\n    ) -> Self {\n        let mut anim = Self {\n            emitters,\n            pending: Vec::new(),\n            layer: None,\n            next_emit: 0,\n            emit_timer: CLASSIC_STAGGER,\n            accumulator: 0.0,\n            last_tick: now,\n            foundation_emitted: [0; FOUNDATION_COLUMNS],\n            card_height: card_height.max(1.0),\n            card_width: card_width.max(1.0),\n            viewport_width: viewport_width.max(1.0),\n            layer_size,\n        };\n        anim.ensure_layer();\n        if let Some(layer) = anim.layer.as_mut() {\n            unsafe { layer.clear(); }\n        }\n        anim\n    }\n\n    fn emitted_from(&self, index: usize) -> usize {\n        self.foundation_emitted.get(index).copied().unwrap_or(0)\n    }\n\n    fn record_clone(&mut self, card: Card, pos: (f32, f32)) {\n        self.pending.push(ClassicClone { card, pos });\n    }\n\n    fn ensure_layer(&mut self) {\n        let (width, height) = self.layer_size;\n        let recreate = match &self.layer {\n            Some(layer) => layer.w != width || layer.h != height,\n            None => true,\n        };\n        if !recreate {\n            return;\n        }\n        if let Some(layer) = self.layer.as_mut() {\n            unsafe { layer.destroy(); }\n        }\n        self.layer = None;\n        if width > 0 && height > 0 {\n            if let Ok(mut buffer) = unsafe { BackBuffer::new(width, height) } {\n                unsafe { buffer.clear(); }\n                self.layer = Some(buffer);\n            }\n        }\n    }\n\n    fn flush_pending(&mut self, state: &WindowState, metrics: &CardMetrics) {\n        if self.pending.is_empty() {\n            return;\n        }\n        self.ensure_layer();\n        if let Some(layer) = self.layer.as_mut() {\n            for clone in self.pending.drain(..) {\n                let x = clone.pos.0.round() as i32;\n                let y = clone.pos.1.round() as i32;\n                draw_card_face_up_to_dc(state, metrics, layer.dc, &clone.card, x, y);\n                let rect = make_rect(x, y, metrics.card_w, metrics.card_h);\n                unsafe { layer.fill_alpha(rect, 255); }\n            }\n        } else {\n            self.pending.clear();\n        }\n    }\n}\n\nimpl Drop for ClassicVictoryAnimation {\n    fn drop(&mut self) {\n        if let Some(layer) = self.layer.as_mut() {\n            unsafe { layer.destroy(); }\n        }\n    }\n}\n\n"""
path.write_text(text.replace(old_impl, new_impl, 1))
