from pathlib import Path

path = Path(r"C:\language\mdsol\src\main.rs")
text = path.read_text()
start = text.index("struct BackBuffer {")
end = text.index("fn status_bar_height")
new_block = """struct BackBuffer {\n    dc: HDC,\n    bmp: HBITMAP,\n    old: HGDIOBJ,\n    bits: *mut u8,\n    stride: i32,\n    w: i32,\n    h: i32,\n}\n\nimpl BackBuffer {\n    unsafe fn new(width: i32, height: i32) -> anyhow::Result<Self> {\n        let dc = CreateCompatibleDC(HDC(0));\n\n        let bi = BITMAPINFO {\n            bmiHeader: BITMAPINFOHEADER {\n                biSize: size_of::<BITMAPINFOHEADER>() as u32,\n                biWidth: width,\n                biHeight: -height, // top-down\n                biPlanes: 1,\n                biBitCount: 32,\n                biCompression: BI_RGB.0,\n                ..Default::default()\n            },\n            ..Default::default()\n        };\n        let mut bits: *mut core::ffi::c_void = core::ptr::null_mut();\n        let bmp = CreateDIBSection(HDC(0), &bi, DIB_RGB_COLORS, &mut bits, None, 0)?;\n        if bmp.is_invalid() {\n            return Err(anyhow::anyhow!(\"CreateDIBSection failed\"));\n        }\n        let old = SelectObject(dc, bmp);\n        let stride = width.max(1) * 4;\n        let mut buffer = Self {\n            dc,\n            bmp,\n            old,\n            bits: bits as *mut u8,\n            stride,\n            w: width,\n            h: height,\n        };\n        buffer.clear();\n        Ok(buffer)\n    }\n\n    unsafe fn clear(&mut self) {\n        if !self.bits.is_null() {\n            let size = (self.stride as isize * self.h as isize).max(0) as usize;\n            std::ptr::write_bytes(self.bits, 0, size);\n        }\n    }\n\n    unsafe fn fill_alpha(&mut self, rect: RECT, alpha: u8) {\n        if self.bits.is_null() {\n            return;\n        }\n        let left = rect.left.clamp(0, self.w);\n        let right = rect.right.clamp(0, self.w);\n        let top = rect.top.clamp(0, self.h);\n        let bottom = rect.bottom.clamp(0, self.h);\n        if left >= right || top >= bottom {\n            return;\n        }\n        let stride = self.stride as isize;\n        for y in top..bottom {\n            let row = self.bits.offset(stride * y as isize);\n            let mut pixel = row.offset((left * 4) as isize);\n            for _ in left..right {\n                *pixel.add(3) = alpha;\n                pixel = pixel.add(4);\n            }\n        }\n    }\n\n    unsafe fn destroy(&mut self) {\n        if self.dc.0 != 0 {\n            if self.old.0 != 0 {\n                let _ = SelectObject(self.dc, self.old);\n            }\n            let _ = DeleteObject(self.bmp);\n            let _ = DeleteDC(self.dc);\n            self.dc = HDC(0);\n            self.bits = std::ptr::null_mut();\n        }\n    }\n}\n\n\n"""
text = text[:start] + new_block + text[end:]
path.write_text(text)
